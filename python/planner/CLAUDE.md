# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

This is a Python-based scheduling planner that generates recurring maintenance schedules for applications based on configurable rules. The main application is a single-file Python script (`planner.py`) that parses English-language scheduling rules and generates planned dates with timezone support.

## Commands

### Running the Application
```bash
python3 planner.py
```
This will generate a JSON output of scheduled maintenance dates based on the rules defined in the script.

```bash
python3 planner.py -i input_file.yaml
```
Run with external YAML/JSON file containing planning rules.

Example with multi-application rules:
```bash
python3 planner.py -i sample_planning_multi_rules.yml
```

### Testing the Application
```bash
python3 -c "import planner; print('Module loads successfully')"
```
Basic module import test to verify syntax correctness.

## Architecture

The application consists of a single Python module with the following key components:

### Core Functions
- `parse_rule()`: Parses English scheduling rules (e.g., "3rd Tuesday March 2025") into components
- `nth_weekday()`: Calculates the nth occurrence of a weekday in a given month
- `add_months()`: Safely adds months to dates while preserving the original day when possible
- `generate_planning()`: Main function that generates the complete schedule based on rules
- `load_planning_rules()`: Loads planning rules from external YAML or JSON files

### Configuration Structure
The application supports both single-rule and multi-rule configurations:

#### Single Application Rules
The `planning_rules` dictionary defines maintenance schedules with:
- **rule**: English description of when to start (e.g., "2nd Thursday June 2025")
- **hour**: Time of day in HH:MM format
- **cycle**: Recurrence pattern (e.g., "3 months", "6 months")
- **meta**: Optional metadata (e.g., environment, OS type) included in output

#### Multi-Application Rules
For managing multiple applications, use nested structure under `planning_rules`:
```yaml
planning_rules:
  patch_app1:
    meta:
      env: dev
      os: Windows
    rules:
      - start: 3rd Tuesday December 2025
        cycle: 3 months
        hour: 02:00
      - start: 1st Wednesday January 2025
        cycle: 12 months
        hour: 13:00
  patch_app2:
    meta:
      env: production
      os: Linux
    rules:
      - start: 1st Wednesday December 2025
        cycle: 2 months
        hour: 02:00
```

Each application can have:
- **meta**: Shared metadata for all rules within that application
- **rules**: Array of scheduling rules, each with:
  - **start**: English description of when to start (replaces "rule")
  - **hour**: Time of day in HH:MM format
  - **cycle**: Recurrence pattern (e.g., "3 months", "6 months")

### Data Flow
1. Rules are parsed from English format into numeric components
2. For each cycle, the nth weekday is recalculated for the target month/year
3. Dates are created starting at midnight (00:00) then adjusted to specified hour
4. Recurring dates are generated by adding cycle months to find next target month
5. All dates are timezone-aware (Europe/Paris) and chronologically sorted
6. Output includes year in format: "Weekday DD Month YYYY HH:MM:SS"

### Key Constants
- `TZ_PARIS`: Europe/Paris timezone for all date calculations
- `YEARS_TO_GENERATE`: Controls how far into the future to generate schedules (default: 2 years)
- Lookup tables for weekday and month name conversion

## Development Notes

- The application uses Python's `zoneinfo` module for timezone handling (Python 3.9+)
- Date arithmetic carefully handles month boundaries to avoid invalid dates
- For each cycle, the nth weekday is recalculated rather than simply adding months to preserve weekday consistency
- Output format includes year and is chronologically sorted using datetime objects
- All scheduling rules follow the pattern: "[ordinal] [weekday] [month] [year]"
- Supports external YAML/JSON configuration files via `-i` parameter
- Comments and documentation are in English